notas del codigo de supermario

[config]

class Config -> genera un dicionario de configuracion --> podemos pasar un json derectamente.


[mario]

fun save_mario > guardar en un archivo binario los pesos y el bias de un modelo
fun get_num_trainable_parameters > calcula y retorna cuanto elementos hay para entrenar
fun get_num_inputs > calcula y retorna la cantidad de entradas en la red neuronal

class Mario > suposicion > procesamiento del frame y lo relaciona con la red neuronal


[neuronal_network]

class FeedForwardNetwork -> implementa la propagacion hacia adelante y la inicializacion de los pesos

implementacion de funciones de activacion: [sigmoid, tanh, relu, leaky_relu, linear]

[nn_viz]

genera con PyQt5 la venta que grafica la NN

[selection]

-fun elitism_selection > Se retorna los individuos elegidos a partir de ordenar la lista de la poblacion de forma descendente
a partir de su puntaje de fitness
-fun roulette_wheel_selection > Se retorna los individuos elegidos usando el metodo de la ruleta. Se arma la ruleta asignando
porciones segun el fitness. Se elige un valor aleatorio y se hace la eleccion de los individuos
-fun tournament_selection > Se generan torneos de tamaÃ±o aleatorio para seleccionar cada individuo donde va quedando el ganador de
cada uno y pasa a la lista de seleccionados

[mutation]

-fun gaussian_mutation > los genes mutan con una distribucion gaussiana
-fun random_uniform_mutation > mutacion mas basica, si el gen es elegido para la mutacion, se le asigna un nuevo valor aleatorio
dentro del rango posible
-fun uniform_mutation_with_respect_to_best_individual > si el gen es elegido para mutar, se busca acercar su valor al valor del mejor
cromosoma
-fun cauchy_mutation > no esta implementado
-fun exponential_mutation > mutacion exponencial basada en funciones que no se de donde saca
-fun mmo_mutation > mutacion que trabaja con un delta que consiste en una normal y una distribucion de cauchy

[crossover]

-fun simulated_binary_crossover > define un metodo de cruza orientado a representaciones de punto flotante
Las formulas salen de https://stackoverflow.com/questions/22457941/simulated-binary-crossover-sbx-crossover-operator-example
-fun uniform_binary_crossover > define el metodo de cruza donde se crea una mascara con 0 y 1. 
-fun single_point_binary_crossover > define el metodo de cruza donde se elige un punto del cromosoma de los padres y se hace un swap de
los bits para crear a los hijos. Aca hace algo mas complicado y no lo entiendo




comandos:
- entrenamiento
python .\smb_ai.py --config "settings.config" --no-display --debug

- correr el mejor de una gen (em este caso 19)
python smb_ai.py --replay-file "/path/to/save/individuals/" --replay-inds 19